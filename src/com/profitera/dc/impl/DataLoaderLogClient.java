package com.profitera.dc.impl;

import com.profitera.log.ILogClient;
import com.profitera.log.ILogProvider;
import com.profitera.log.ILogProvider.Level;

public class DataLoaderLogClient implements ILogClient {
  private static final String LONG_FORMAT = ",number,####################";
  public static final String DATETIME_FORMAT = ",date,yyyy-MM-dd kk:mm:ss,SSS";
  public static final String LOOKUP_OPTIONAL_ATTR = "LOOKUP_OPTIONAL_ATTR";
  public static final String EXT_SCRIPT_OUT = "LOAD_EXT_SCRIPT_OUTPUT";
  public static final String BAD_WRITE_FAIL = "LOAD_BAD_FILE_FAIL";
  public static final String TRACE_WRITE_FAIL = "LOAD_TRACE_FILE_FAIL";
  public static final String LOAD_DB_INSERT = "LOAD_DB_INSERT";
  public static final String LOAD_DB_UPDATE = "LOAD_DB_UPDATE";
  public static final String LOAD_DB_INSERT_KEY = "LOAD_DB_INSERT_KEY";
  public static final String LOAD_DB_POST_INSERT_UPDATE = "LOAD_DB_POST_INSERT_UPDATE";
  public static final String LOAD_DB_POST_UPDATE_UPDATE = "LOAD_DB_POST_UPDATE_UPDATE";
  public static final String LOAD_DB_POST_INSERT_INSERT = "LOAD_DB_POST_INSERT_INSERT";
  public static final String LOAD_DB_POST_UPDATE_INSERT = "LOAD_DB_POST_UPDATE_INSERT";
  public static final String LOAD_DB_LINE_ERROR = "LOAD_DB_LINE_ERROR";
  public static final String LOAD_RECREATE_NATIVE = "LOAD_NATIVE_RECREATING";
  public static final String LOAD_NOT_RECREATE_NATIVE = "LOAD_NATIVE_NOT_RECREATING";
  public static final String RUN_NATIVE_LOAD = "LOAD_EXECUTE_NATIVE_LOADER";
  public static final String RUN_SP = "LOAD_EXECUTE_SP";
  public static final String END_SP = "LOAD_COMPLETED_SP";
  public static final String ELIGIBLE_LOADED = "LOAD_TOTAL_LOADED";
  public static final String WILL_PARSE_LOAD = "LOAD_PARSING";
  public static final String NOT_XML_PARSE_LOAD = "LOAD_NOT_XML";
  public static final String LOAD_BAD_DRIVER = "LOAD_BAD_DRIVER";
  public static final String LOAD_NO_DRIVER = "LOAD_NO_DRIVER";
  public static final String LOAD_FROM = "LOAD_FROM";
  public static final String LOAD_WITH = "LOAD_WITH";
  public static final String LOAD_GENERATED_CONF = "LOAD_GEN_SQL";
  public static final String NO_DELTA = "LOAD_NO_DELTA";
  public static final String NO_DELTA_FILE = "LOAD_NO_DELTA_FILE";
  public static final String ATTEMPT_SORT = "LOAD_ATTEMPT_SORT";
  public static final String ATTEMPT_SORT_FILE = "LOAD_ATTEMPT_SORT_FILE";
  public static final String CONFLICTING_DELIMITERS = "LOAD_CONFLICTING_DELIMITERS";
  public static final String WAIT_CONTROL_FILE = "WAIT_CONTROL_FILE";
  @Override
  public void registerMessages(ILogProvider provider) {
    provider.registerMessage(this, LOOKUP_OPTIONAL_ATTR, Level.W,
        "Configuration element 'lookup' should specify 'isoptional' attribute for field {0}, defaulting to field-level value",
        "Though not previously required lookup definitions now require their own optional specification due to changes in "
        + "the behaviour of the 'isoptional' attribute for non-lookup fields. The configuration will still honour the old "
        + "behaviour but may not in the future.");
    provider.registerMessage(this, EXT_SCRIPT_OUT, Level.I, "{0}: {1}",
        "Prints the output generated by an external script executed by the loader as part of loading.");
    provider.registerMessage(this, BAD_WRITE_FAIL, Level.E, "Failed to write to bad lines file for {0}",
        "Failed to write to load bad file lines.");
    provider.registerMessage(this, TRACE_WRITE_FAIL, Level.E, "Failed to write to stacktrace file for {0}",
        "Failed to write to load stack trace file.");
    provider.registerMessage(this, LOAD_DB_INSERT, Level.D, "{0} insert executed with {1}",
        "Inserted a record in the database with the indicated arguments.");
    provider.registerMessage(this, LOAD_DB_UPDATE, Level.D, "{0} update executed with {1}",
        "Updated a record in the database with the indicated arguments.");
    provider.registerMessage(this, LOAD_DB_INSERT_KEY, Level.D, "{0} insert generated key value {1}",
        "Inserted record was assigned key value.");
    provider.registerMessage(this, LOAD_DB_POST_INSERT_UPDATE, Level.D, "{0} executed post-insert update with {1}",
        "Inserted record triggered a post-insert update.");
    provider.registerMessage(this, LOAD_DB_POST_UPDATE_UPDATE, Level.D, "{0} executed post-update update with {1}",
        "Updated record triggered a post-update update.");
    provider.registerMessage(this, LOAD_DB_POST_INSERT_INSERT, Level.D, "{0} executed post-insert insert with {1}",
        "Inserted record triggered a post-insert insert.");
    provider.registerMessage(this, LOAD_DB_POST_UPDATE_INSERT, Level.D, "{0} executed post-update insert with {1}",
        "Updated record triggered a post-update insert.");
    provider.registerMessage(this, LOAD_DB_LINE_ERROR, Level.E, "Line {0} to {1} {2}",
        "Lines could not be loaded into the database due to a database error indicated by the message.");
    provider.registerMessage(this, LOAD_NOT_RECREATE_NATIVE, Level.I, "{0}",
        "Not recreating the stored procedure or intermediate table for loading.");
    provider.registerMessage(this, LOAD_RECREATE_NATIVE, Level.I, "{0}",
        "Recreating the stored procedure or intermediate table for loading.");
    provider.registerMessage(this, RUN_NATIVE_LOAD, Level.I, "{0}",
        "Running load into intermediate table using native loader.");
    provider.registerMessage(this, RUN_SP, Level.I, "{0} for lines {1} - {2}",
        "Running stored procedure to process intermediate table rows.");
    provider.registerMessage(this, END_SP, Level.I, "{0} for lines {1} - {2}, {3} rows/sec",
        "Running stored procedure to process intermediate table rows.");
    provider.registerMessage(this, ELIGIBLE_LOADED, Level.I, "{0} loaded {1" + LONG_FORMAT + "} of {2" + LONG_FORMAT + "} eligible lines in {3" + LONG_FORMAT + "} seconds {4} rows/sec",
        "Count of loaded rows that were not filtered.");
    provider.registerMessage(this, WILL_PARSE_LOAD, Level.I, "Attempting to parse configuration file {0} for {1}",
        "Indicating the start of load parsing.");
    provider.registerMessage(this, NOT_XML_PARSE_LOAD, Level.I, "Unable parse configuration file {0} as XML for load {1}",
        "Loading configuration as XML has failed, an attempt to parse as a properties file will be executed.");
    provider.registerMessage(this, CONFLICTING_DELIMITERS, Level.W, "Configuration file {0} specifies a regular delimiter and an ascii codepoint delimiter",
        "Loading configuration as XML has a 'delimiter' and an 'asciidelimiter' attribute specified, the system will default to the delimiter value after issuing this warning.");
    
    provider.registerMessage(this, LOAD_BAD_DRIVER, Level.E, "Unable to load driver {0} for data source {1} for load {2}",
        "Unable to load JDBC driver for loading target datasource.");
    provider.registerMessage(this, LOAD_NO_DRIVER, Level.E, "Unable to load driver, property DRIVER not specified for data source {0} for load {1}",
        "Unable to load JDBC driver for loading target datasource.");
    provider.registerMessage(this, LOAD_FROM, Level.I, "Loading from {0} for load {1}", "Indicates start of loading from source file.");
    provider.registerMessage(this, LOAD_WITH, Level.I, "Loading using software version {0} for load {1}", "Indicates version of DataLoader being used to load file.");
    provider.registerMessage(this, LOAD_GENERATED_CONF, Level.I, "Generated SQL configuration file URL {0} for load {1}",
        "In the case of abnormal termination the generated SQL for this load can be referenced from the indicated path expressed as a URL.");
    provider.registerMessage(this, NO_DELTA, Level.W, "No delta generated for load {0}", "A delta file can not be generated for load.");
    provider.registerMessage(this, ATTEMPT_SORT, Level.I, "Will attempt to sort source files for delta generation after receiving message ''{0}'' for load {1}", "Attempt to sort in-place using disk based sorting in order to create proper delta for processing.");
    provider.registerMessage(this, NO_DELTA_FILE, Level.I, "No delta can be generated, previous file expected at {0} not found for load {1}",
        "A delta file can not be generated for load.");
    provider.registerMessage(this, ATTEMPT_SORT_FILE, Level.I, "File at {0} with last modified time of {1" + DATETIME_FORMAT + "} will be sorted in place for load {2}",
        "Sorting the target file will be performed.");
    provider.registerMessage(this, WAIT_CONTROL_FILE, Level.I, "Waiting for control file {0} for load {1} until {2" + DATETIME_FORMAT + "}",
        "A delta file can not be generated for load.");
  }

  @Override
  public String getName() {
    return "Data Loader";
  }

}
